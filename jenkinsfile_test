//Se genera el mapa con la configuración
Map config = [
    //Unos corhcetes {} significan que vas a meter un trozo de código. Como si ejecutases algo dentro del if
    branchType:{
        if (env.GIT_BRANCH_NAME == 'master') {
            return 'MASTER'
                // Se tira de regex para saber como empieza la rama
        }
        else if (env.GIT_BRANCH_NAME ~== 'feature.*') {
            return 'FEAT'
        }
        else if (env.GIT_BRANCH_NAME ~== 'break.*') {
            return 'BREAK'
        }
        else if (env.GIT_BRANCH_NAME ~== 'fix.*') {
            return 'FIX'
        }
        else {
            return 'UKNOWN'
        }
    },
        // Url del repo, https://stackoverflow.com/questions/45937337/jenkins-pipeline-get-repository-url-variable-under-pipeline-script-from-scm
        httpRepoUrl: scm.userRemoteConfigs[0].url,
        githubToken : {
        withCredentials([usernameColonPassword(credentialsId:'idSecretoJenkins', variable : 'GITHUB_TOKEN')]) {
            return $GITHUB_TOKEN
        }
    }
]
pipeline{
    agent {
        kubernetes {
            yaml '''
                apiVersion: v1
                kind : Pod
                spec :
                  hostAliases:
                  -ip : "192.168.2.80"
                    hostnames :
                    -"pre.jenkins.com"
                  imagePullSecrets :
                  -name : nexus - pre
                  containers :
                  -name : jnlp
                    image : pre.docker.nexus.com / jnlp - custom : 0.0.0
                  - name : alpine - core
                    image : pre.docker.nexus.com / alpine - core : 0.0.0
                    command :
                    -cat
                    tty : true
            '''
        }
    }
    stages {
        stage('Get next version') {
            steps {
                script {
                    if (isValidBranch()) {
                        String lastTag = lastTag()
                        String nextTag = calculateNextTag(lastTag)
                        createTag(nextTag)
                            //etc... lo dejo aquí que he de dormir, la idea es que puedes tener un código más claro con funciones y que hasd e darle duro a los tags y como calcular el siguiente. Después pásate a la parte del build, docker, helm, etc
                        }
                    }
                 }
            }
            stage('Build app') {
                //Has de contruir el proyecto de front para que el Dockerfile lo recoja
                steps {
                    script {
                        if (isValidBranch()) {
                        }
                    }
                }
            }
            stage('Crear Namespaces') {
                steps {
                    script {

                        def kubeconfig = '/ruta/kubeconfig'
                        sh script : "kubectl --kubeconfig=${kubeconfig} create namespace produccion", returnStatus : true
                        sh script : "kubectl --kubeconfig=${kubeconfig} create namespace preproduccion", returnStatus : true
                        }
                    }
                }
            }
            stage('Docker') {
                steps {
                    script {
                        if (isValidBranch()) {
                            //Copia repo y sube a Nexus
                            dockerImageName ="NombreImagen"
                            writeFile file : 'Dockerfile', text : '''
                                FROM node : alpine
                                RUN apk update && apk add --no - cache docker - cli
                                WORKDIR / app
                                COPY . / app
                                # Add other Dockerfile instructions as needed
                            '''
                            def dockerImageName = "pre.nexus.com/${JOB_NAME}:${version}"
                            sh "docker tag $dockerImageName $dockerImageName:$nextTag"
                            sh "docker build -t ${dockerImageName} ."
                            sh "docker push ${dockerImageName}"
                            

                        }
                    }
                }
            }
            stage('Helm') {
                //Implementar quí despliegue de Helm
                steps {
                    script {
                        if (isValidBranch()) {
                            sh script : "helm --kubeconfig=${kubeconfig} install mi-release mi-chart --namespace=${namespace} -f values-${namespace}.yaml"
                        }
                    }
                }
            }
        }
        post {
            always {
                // Limpieza o acciones finales que deben realizarse sin importar el resultado
            }
            success {
                echo "Pipeline completed successfully"
            }
            failure {
                echo "Pipeline failed"
                // Agregar aquí acciones adicionales en caso de que el pipeline falle
            }
        }
}

boolean isValidBranch() {
            return config.branchType != 'UKNOWN'
        }

        boolean isFeature() {
            return config.branchType == 'FEAT'
        }

        boolean isBreak() {
            return config.branchType == 'BREAK'
        }

        boolean isFix() {
            return config.branchType == 'FIX'
        }

        boolean isPullRequestToMaster() {
            //https://github.com/KostyaSha/github-integration-plugin/blob/master/docs/Configuration.adoc
            return env.CHANGE_TARGET == 'refs/heads/master'
        }

        String lastTag() {
            /*
              El sh ejecuta sentencias bash
              Obten los tags remotos
            */
            sh('git ls-remote --tags origi')
                //Ordenalos alfanuméricamente para obtener el último
                return sh(script: 'git describe --tags --abbrev=0', stdout : true)
        }

        String calculateNextTag(String lastTag) {
            String nextTag = '0.0.0'
            def tagParts = lastTag.split('\\.')
            def x = tagParts[0] as int
            def y = tagParts[1] as int
            def z = tagParts[2] as int
                //En mi caso, solo si es pull request a master generare la nueva version
                if (env.GITHUB_EVENT_NAME == 'push') {
                    //Esta parte te la dejo a ti, quiero dormir (ten en cuenta si no hay tags en el repo)
                    if (isFeature()) {
                        y++
                    }
                    else if (isBreak()) {
                        x++
                    }
                    else if (isFix()) {
                        z++
                    }
                    nextTag = "$x.$y.$z"
                    return nextTag
                }
        }

        void createTag(String nextTag) {
            echo("Siguiente version calculada: ${nextTag}")
                sh("git tag ${nextTag}")
        }
